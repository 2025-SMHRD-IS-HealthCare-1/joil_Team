// server.js
const fs = require('fs');                       // íŒŒì¼/ì¸ì¦ì„œ
const https = require('https');                 // HTTPS ì„œë²„
const express = require('express');             // express ë³¸ì²´
const path = require('path');                   // ê²½ë¡œ
const cookieParser = require('cookie-parser');  // ì¿ í‚¤
const session = require('express-session');     // ì„¸ì…˜
const os = require('os');                       // LAN IP ì¡°íšŒ
const { createProxyMiddleware, responseInterceptor } = require('http-proxy-middleware'); // í”„ë¡ì‹œ
// Node 18 ë¯¸ë§Œ í˜¸í™˜ìš©
const fetch = global.fetch || ((...a) => import('node-fetch').then(({ default: f }) => f(...a)));
// ì•±
const app = express();

// ===== ë¡œì»¬ IPv4 (ë¡œê·¸ìš©) =====
function getLocalIPv4() {
  const interfaces = os.networkInterfaces();
  for (const name of Object.keys(interfaces)) {
    for (const iface of interfaces[name]) {
      if (iface.family === 'IPv4' && !iface.internal) return iface.address;
    }
  }
  return 'localhost';
}
const localIP = getLocalIPv4();

// ===== HTTPS ì¸ì¦ì„œ (ì—†ìœ¼ë©´ HTTPë¡œ í´ë°±) =====
let httpsOptions = null;
try {
  const keyPath  = path.join(__dirname, 'key.pem');
  const certPath = path.join(__dirname, 'cert.pem');
  if (fs.existsSync(keyPath) && fs.existsSync(certPath)) {
    httpsOptions = {
      key:  fs.readFileSync(keyPath),
      cert: fs.readFileSync(certPath),
    };
    console.log('ğŸ” HTTPS cert loaded');
  } else {
    console.warn('âš  key.pem / cert.pem not found -> HTTP fallback');
  }
} catch (e) {
  console.warn('âš  cert load failed -> HTTP fallback:', e && e.message);
}

// ===== ê³µí†µ ë¯¸ë“¤ì›¨ì–´ =====
app.use(cookieParser());
app.use(express.urlencoded({ extended: true }));
app.use(express.json());

// ì •ì : ê¸°ì¡´ /public ë£¨íŠ¸ + /static ë³„ì¹­ ì œê³µ (viewsì—ì„œ /static/* ë¡œ ì°¸ì¡°)
const staticOpts = { maxAge: '1h', etag: true, immutable: true };
app.use(express.static(path.join(__dirname, 'public'), staticOpts));
app.use('/static', express.static(path.join(__dirname, 'public'), staticOpts));

// ===== ì„¸ì…˜ (HTTP/HTTPS ëª¨ë‘ ë™ì‘í•˜ë„ë¡) =====
app.set('trust proxy', 1);
const isProdLike = !!httpsOptions; // ì¸ì¦ì„œ ìˆìœ¼ë©´ HTTPSë¡œ ë„ìš´ë‹¤ê³  ê°€ì •
app.use(session({
  secret: 'vitamind_secret_key',
  resave: false,
  saveUninitialized: true,
  cookie: {
    httpOnly: true,
    maxAge: 1000 * 60 * 60,
    secure: isProdLike,          // HTTPSì¼ ë•Œë§Œ secure
    sameSite: isProdLike ? 'none' : 'lax', // HTTPì¼ ë•ŒëŠ” lax
  }
}));

// ===== ë·° ì—”ì§„ (ì„œë²„2: EJS) =====
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'ejs');

app.get('/admin', (req, res) => {
  const user = req.session.user || { id: 'guest', name: 'Guest', admin_yn: 'Y' };
  return res.render('admin', { user });
});

// ===== ë¼ìš°í„°/ë¯¸ë“¤ì›¨ì–´ ë¡œë“œ =====
const pageRouter = require('./routes/pageRouter'); // ì„œë²„1
const dbRouter = require('./routes/dbRouter');     // ì„œë²„1

// ì„œë²„2 ë¼ìš°í„°ë“¤
const adminRouter = require('./routes/admin');
const apiRouter = require('./routes/api');
const dashboardRouter = require('./routes/dashboard');

const { redirectAdminFromMe } = require('./middlewares/guards');

// ===== ì‹œë®¬ë ˆì´í„°(ì„œë²„1 ìœ ì§€) =====
try {
  const sim = require('./sim_monitor');
  const simAlertRouter = require('./routes/simAlertRouter');
  app.use('/sim', simAlertRouter);
  sim.start();
} catch (e) {
  console.warn('[sim] skip:', e && e.message);
}

// ===== í”„ë¡ì‹œ(ì„œë²„1 ìœ ì§€) =====
// ì„œë²„2 í”„ë¡ì‹œ ì˜ˆ: /s2 â†’ 3002 (í•„ìš”ì‹œ ìœ ì§€/ì •ë¦¬)
app.use('/s2', createProxyMiddleware({
  target: 'http://localhost:3002',
  changeOrigin: true,
  pathRewrite: { '^/s2': '' },
  xfwd: true,
  logLevel: 'warn'
}));

function proxyErrorHandler(err, req, res) {
  // í”„ë¡ì‹œ ì‹¤íŒ¨ ì‹œ ë¹ˆ ì‘ë‹µ ëŒ€ì‹  JSONìœ¼ë¡œ
  if (!res.headersSent) {
    res.status(502).json({ ok:false, message:'rasp proxy failed', detail: String(err && err.message || err) });
  } else {
    res.end();
  }
}
app.use((req, _res, next) => {
  if (req.url.startsWith('rapi/')) req.url = '/' + req.url;
  next();
});
app.get('/rapi/health', async (req, res) => {
  try {
    // node 18+ ëŠ” fetch ë‚´ì¥. ì´í•˜ ë²„ì „ì´ë©´ node-fetch ì„¤ì¹˜ í•„ìš”.
    const r = await fetch(`${RASP_BASE.replace(/\/+$/, '')}/health`);
    const text = await r.text();
    res.set('content-type', r.headers.get('content-type') || 'application/json; charset=utf-8');
    res.status(r.status).send(text);
  } catch (e) {
    res.status(502).json({ ok: false, message: 'rasp health unreachable', detail: String((e && e.message) || e) });
  }
});

// ë¼íŒŒ FastAPI í”„ë¡ì‹œ + ê°€ë²¼ìš´ ìºì‹œ
const RASP_BASE = process.env.RASP_BASE || 'http://192.168.219.216:8000';

// ê°„ë‹¨ ìºì‹œ(Map). key: req.path (ex: /rapi/sensor), value: { ts, body, status, headers }
const raspCache = new Map();
const CACHE_TTL_MS = 8000;
const CACHEABLE = new Set(['/sensor', '/dht', '/gps']); // STTëŠ” ìºì‹œ ê¸ˆì§€

app.use('/rapi', createProxyMiddleware({
  target: RASP_BASE,
  changeOrigin: true,
  pathRewrite: { '^/rapi': '' },
  xfwd: true,
  ws: false,
  timeout: 20000,
  proxyTimeout: 20000,
  onError: proxyErrorHandler,
preserveHeaderKeyCase: true,
  logLevel: 'warn',
  selfHandleResponse: true, // ì‘ë‹µ ê°€ë¡œì±„ì„œ ìºì‹œ
  onProxyReq(proxyReq, req, res) {
    // ìºì‹œ íˆíŠ¸ë©´ ì›ê²©ìœ¼ë¡œ ì•ˆ ë³´ëƒ„ (ë°”ë¡œ ë°˜í™˜)
    const url = new URL(req.url, 'http://x'); // /sensor ê°™ì€ path
    if (req.method === 'GET' && CACHEABLE.has(url.pathname)) {
      const hit = raspCache.get(url.pathname);
      if (hit && (Date.now() - hit.ts) < CACHE_TTL_MS) {
        res.statusCode = hit.status;
        // ìµœì†Œí•œì˜ í—¤ë”ë§Œ ë³µì›
        res.setHeader('content-type', hit.headers['content-type'] || 'application/json; charset=utf-8');
        res.setHeader('x-rasp-cache', 'HIT');
        return res.end(hit.body);
      }
    }
    // ë¯¸ìŠ¤ â†’ í”„ë¡ì‹œ ìš”ì²­ ì§„í–‰
  },
  onProxyRes: responseInterceptor(async (buffer, proxyRes, req, res) => {
    const url = new URL(req.url, 'http://x');
    // ìºì‹œ ê°€ëŠ¥í•œ ì—”ë“œí¬ì¸íŠ¸ë§Œ ì €ì¥
    if (req.method === 'GET' && CACHEABLE.has(url.pathname) && proxyRes.statusCode === 200) {
      raspCache.set(url.pathname, {
        ts: Date.now(),
        body: buffer,
        status: proxyRes.statusCode,
        headers: { 'content-type': proxyRes.headers['content-type'] }
      });
      res.setHeader('x-rasp-cache', 'MISS');
    }
    return buffer; // ì›ë³¸ ê·¸ëŒ€ë¡œ ë°˜í™˜
  })
}));


// ì„œë²„2 ëŒ€ì‹œë³´ë“œ í”„ë¡ì‹œ (í•„ìš”ì‹œ ìœ ì§€)
app.use('/dashboard', createProxyMiddleware({
  target: 'http://localhost:3001',
  changeOrigin: true,
  pathRewrite: { '^/dashboard': '/' }
}));

// ===== ë¼ìš°íŒ… ìˆœì„œ (ì¤‘ìš”) =====
// 1) ì„œë²„2: ì¸ì¦/í™”ë©´ ë¨¼ì € => /login, /signup, /logout ë“± EJS ë Œë” ìš°ì„ 
app.use('/api', apiRouter);
app.use('/admin', adminRouter);
app.use('/', redirectAdminFromMe, dashboardRouter);

// 3) ì„œë²„1: ê¸°ì¡´ DB/API & í˜ì´ì§€ ë¼ìš°í„° (ë’¤ìª½ì—)
//   - pageRouterì— /login ì •ì  ë¼ìš°íŠ¸ê°€ ìˆì–´ì„œ, ìœ„ì—ì„œ EJS /loginì´ ë¨¼ì € ë¨¹ë„ë¡ ìˆœì„œ ë°°ì¹˜
app.use('/db', dbRouter);
app.use('/', pageRouter);

// ===== ì„œë²„ ì‹¤í–‰ (HTTPS ìˆìœ¼ë©´ 3000/HTTPS, ì—†ìœ¼ë©´ 3000/HTTP) =====
const PORT = process.env.PORT || 3000;
if (httpsOptions) {
  https.createServer(httpsOptions, app).listen(PORT, '0.0.0.0', () => {
    console.log('âœ… VitaMind HTTPS server');
    console.log(`- local: https://localhost:${PORT}`);
    console.log(`- lan  : https://${localIP}:${PORT}`);
    console.log('  if browser warns, continue anyway.');
  });
} else {
  app.listen(PORT, '0.0.0.0', () => {
    console.log('âœ… VitaMind HTTP server (fallback)');
    console.log(`- local:  http://localhost:${PORT}`);
    console.log(`- lan  :  http://${localIP}:${PORT}`);
  });
}
